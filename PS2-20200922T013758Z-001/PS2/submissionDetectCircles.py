
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# Edit DetectCircles.ipynb instead.
import numpy as np
import matplotlib.pyplot as plt
from imageio import imread,imsave
from skimage.feature import canny
from skimage.color import rgb2gray
from skimage.draw import circle_perimeter
from skimage import img_as_float
from scipy.ndimage.filters import convolve
from skimage import measure

def detect_circles(img, radius, use_Grad=False, sigma=1.0, threshold=0.8, epsilon='auto', bin_scale=1, hough=False):
    
    # Detect edges 
    img_gray = img_as_float(rgb2gray(img))
    edges = canny(img_gray, sigma=sigma)
    
    #For examples using gradient
    if use_Grad:
        g_x = convolve(img_gray, np.array([[1,-1]]), mode='wrap')
        g_y = convolve(img_gray, np.array([[1],[-1]]), mode="wrap")
        g_x[g_x == 0] = 1e-10
        g_direct = np.arctan(g_y / g_x)
    
    # Detect circles 
    flag = False
    if type(radius) is not list:
        flag = True
        radius = [radius, radius + 1]
    temp_0 = radius[1] - radius[0]
    temp_1 = int(img.shape[0] * bin_scale)
    temp_2 = int(img.shape[1] * bin_scale)
    votes = np.zeros((temp_0, temp_1, temp_2))
    for rad in range(radius[0], radius[1]):
        hough_space = np.zeros((temp_1, temp_2))
        for row in range(img.shape[0]):
            for col in range(img.shape[1]):
                if edges[row, col] != 0:
                    if not use_Grad and epsilon == 'auto':
                        v = np.linspace(0, 2 * np.pi, 6 * rad)
                    elif not use_Grad and epsilon!= 'auto':
                        v = np.arange(0, 2 * np.pi, epsilon)
                    if use_Grad:
                        theta = g_direct[row, col]
                        v = np.array([theta, theta-np.pi])
                    for theta in v:
                        vote_x = int(round(col + rad * np.cos(theta)) * bin_scale)
                        vote_y = int(round(row + rad * np.sin(theta)) * bin_scale)
                        if vote_x >= 0 and vote_x < hough_space.shape[1] and vote_y >= 0 and vote_y < hough_space.shape[0]:
                            hough_space[vote_y, vote_x] = hough_space[vote_y, vote_x] + 1
        votes[rad - radius[0]] = hough_space

    if flag:
        hough_space = votes[0]
        centers = (np.transpose(np.array(np.where(hough_space >= hough_space.max() * threshold))) / bin_scale).astype(int)
        if not hough:
            return centers
        return centers, hough_space
    else:
        centroid = (np.transpose(np.array(np.where(votes >= votes.max() * threshold))) / bin_scale).astype(int)
        centroid[:, 0] = centroid[:, 0] + radius[0]
        if not hough:
            return centroid
        return centroid, votes

def extraCredit():
    egg_img = np.array(imread('./egg.jpg'))
    jupiter_img = np.array(imread('./jupiter.jpg'))
    draw_color = np.array([255, 255, 0])
    
    radius = [2,12]
    sigma = 2
    threshold = 0.65
    use_gradient = False
    bin_scale = 1
    epsilon = 0.05

    centers, hough_space = detect_circles(egg_img, radius, use_Grad=use_gradient, threshold=threshold, sigma=sigma, bin_scale=bin_scale, epsilon=epsilon, hough=True)

    hough_img = hough_space.astype(int).sum(axis=0)
    scale_factor = 255 / hough_img.max()
    hough_img = (scale_factor * hough_img).astype(np.uint8)
    circled_img = egg_img.copy()
    for center in centers:
        circle = circle_perimeter(center[1], center[2], radius=center[0], shape=img.shape)
        circled_img[circle] = draw_color

    plt.rcParams['figure.figsize'] = [16, 10]
    fig, axs = plt.subplots(1, 2)
    axs[0].imshow(circled_img)
    axs[1].imshow(hough_img, cmap='gray')
    axs[0].title.set_text('Circles Marked')
    axs[1].title.set_text('Accumulator Array')
    plt.show()
    
    hough_img = hough_space
    hough_img_threshold = hough_img.copy()
    hough_img_threshold[hough_img < hough_img.max() * threshold] = 0
    hough_img_threshold[hough_img_threshold > 0] = 1
    hough_img_threshold = hough_img_threshold.astype(bool)

    labels = measure.label(hough_img_threshold, background=0)
    count = labels.max()
    centers = []
    for i in range(1, count + 1):
        centers.append((np.mean(np.array(np.where(labels == i)), axis=1) / bin_scale).astype(int))
    centers = np.array(centers)

    circled_img = egg_img.copy()
    for center in centers:
        circle = circle_perimeter(center[1], center[2], radius=center[0] + radius[0], shape=img.shape)
        circled_img[circle] = draw_color

    print('Circle Count:', count)

if __name__ == '__main__':
    egg_img = np.array(imread('./egg.jpg'))
    jupiter_img = np.array(imread('./jupiter.jpg'))
    draw_color = np.array([255, 255, 0]) #yellow for circles 
    
    
    # test 1
    img = jupiter_img
    radius = 110
    sigma = 6
    threshold = 0.99
    use_Grad = False
    bin_scale = 1
    epsilon = 0.1
    circled_img = img.copy()
    centers, votes = detect_circles(img, radius, use_Grad=use_Grad, threshold=threshold, sigma=sigma, bin_scale=bin_scale, epsilon=epsilon, hough=True)
    scale_factor = 255 / votes.max()
    hough_img = (scale_factor * votes).astype(np.uint8)
    for center in centers:
        circle = circle_perimeter(center[0], center[1], radius=radius, shape=img.shape)
        circled_img[circle] = draw_color
    plt.rcParams['figure.figsize'] = [16, 10]
    fig, axs = plt.subplots(1, 2)
    axs[0].imshow(circled_img)
    axs[1].imshow(hough_img, cmap='gray')
    axs[0].title.set_text('Circles Marked')
    axs[1].title.set_text('Accumulator Array')
    plt.show()
    # For grader, feel free to uncomment and run extraCredit,
    # I put the parameters for egg.jpg only, you could change filename 
    # extraCredit()