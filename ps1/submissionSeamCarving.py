
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# Edit v3.ipynb instead.
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage, signal
from imageio import imread, imsave

def  rgb2gray(img):
    """
    Converts an RGB image into a greyscale image

    Input: ndarray of an RGB image of shape (H x W x 3)
    Output: ndarray of the corresponding grayscale image of shape (H x W)

    """

    if(img.ndim != 3 or img.shape[-1] != 3):
        print("Invalid image! Please provide an RGB image of the shape (H x W x 3) instead.".format(img.ndim))
        return None

    return np.dot(img[...,:3], [0.2989, 0.5870, 0.1140])

def compute_gradients(img):
    """
    Computes the gradients of the input image in the x and y direction using a
    differentiation filter.

    ##########################################################################
    # TODO: Design a differentiation filter and update the docstring. Stick  #
    # to a pure differentiation filter for this assignment.                  #
    # Hint: Look at Slide 14 from Lecture 3: Gradients.                      #
    ##########################################################################

    Input: Grayscale image of shape (H x W)
    Outputs: gx, gy gradients in x and y directions respectively

    """
    gray = np.copy(img)
    if (len(gray) == 3):
        gray = rgb2gray(gray)
#     gx = gy = np.zeros_like(img)
    gx = -ndimage.prewitt(gray, axis=1, mode='constant')
    gy = -ndimage.prewitt(gray, axis=0, mode='constant')

    ##########################################################################
    # TODO: Design a pure differentiation filter and use correlation to      #
    # compute the gradients gx and gy. You might have to try multiple        #
    # filters till the test below passes. All the tests after will fail if   #
    # this one does not pass.                                                #
    ##########################################################################
    return gx, gy

def energy_image(img):
    """
    Computes the energy of the input image according to the energy function:

        e(I) = abs(dI/dx) + abs(dI/dy)

    Use compute_gradients() to help you calculate the energy image. Remember to normalize
    energyImage by dividing it by max(energyImage).

    Input: image of the form (H x W) or (H x w x 3)
    Output: array of energy values of the image computed according to the energy function.

    """
#     energyImage = np.zeros_like(img)
    if (len(img.shape) == 3):
        img = rgb2gray(img)
    gx, gy = compute_gradients(img)
    image = abs(gx) + abs(gy)
    image = image / np.max(image)

    ##########################################################################
    # TODO: Compute the energy of input using the defined energy function.   #                                             #
    ##########################################################################

    return image

def cumulative_minimum_energy_map(energyImage, seamDirection):
    """
    Calculates the cumulative minim energy map according to the function:

        M(i, j) = e(i, j) + min(M(i-1, j-1), M(i-1, j), M(i-1, j+1))

    Inputs:
        energyImage: Results of passign the input image to energy_image()
        seamDirection: 'HORIZONTAL' or 'VERTICAL'

    Output: cumulativeEnergyMap

    """

#     cumulativeEnergyMap = np.zeros_like(energyImage)
    if (len(energyImage.shape) == 3):
        energyImage = rgb2gray(energyImage)
#         print("rgb2gray")
    if seamDirection == "HORIZONTAL":
        energyImage = energyImage.T
#     print(energyImage.shape)
#     print(len(energyImage))
    rows, columns = energyImage.shape
    cumulative_minimum_energy = np.zeros((rows, columns), dtype='float64')
    cumulative_minimum_energy[0] = energyImage[0]
    for i in range(1, rows):
        for j in range(columns):
            val1 = cumulative_minimum_energy[i-1][j - 1] if j > 0 else cumulative_minimum_energy[i-1][j]
            val2 = cumulative_minimum_energy[i-1][j]
            val3 = cumulative_minimum_energy[i-1][j + 1] if j < columns - 1 else cumulative_minimum_energy[i-1][j]
            cumulative_minimum_energy[i][j] = energyImage[i][j] + min(val1, val2, val3)
    if seamDirection == "HORIZONTAL":
        cumulative_minimum_energy = cumulative_minimum_energy.T
    return cumulative_minimum_energy

    ##########################################################################
    # TODO: Compute the cumulative minimum energy map in the input           #
    # seamDirection for the input energyImage. It is fine it is not fully    #
    # vectorized.                                                            #
    ##########################################################################

#     return cumulativeEnergyMap

def find_optimal_vertical_seam(cumulativeEnergyMap):
    """
    Finds the least connected vertical seam using a vertical cumulative minimum energy map.

    Input: Vertical cumulative minimum energy map.
    Output:
        verticalSeam: vector containing column indices of the pixels in making up the seam.

    """

#     verticalSeam = [0]*cumulativeEnergyMap.shape[0]
    rows, columns = cumulativeEnergyMap.shape
    result = []
    minColumn = 0
    min = cumulativeEnergyMap[rows-1][minColumn]
    for j in range(1, columns):
        if cumulativeEnergyMap[rows-1][j] < min:
            minColumn = j
            min = cumulativeEnergyMap[rows-1][minColumn]
    result.append(minColumn)
    for i in range(rows - 2, -1, -1):
        min = cumulativeEnergyMap[i][minColumn]
        for j in range(minColumn - 1, minColumn + 2):
            if j >= 0 and j < columns:
                if cumulativeEnergyMap[i][j] < min:
                    minColumn = j
                    min = cumulativeEnergyMap[i][minColumn]
        result.append(minColumn)
    return result[::-1]

    ##########################################################################
    # TODO: Find the minimal connected vertical seam using the input         #
    # cumulative minimum energy map.                                         #
    ##########################################################################

#     return verticalSeam

def find_optimal_horizontal_seam(cumulativeEnergyMap):
    """
    Finds the least connected horizontal seam using a horizontal cumulative minimum energy map.

    Input: Horizontal cumulative minimum energy map.
    Output:
        horizontalSeam: vector containing row indices of the pixels in making up the seam.

    """
#     horizontalSeam = [0]*cumulativeEnergyMap.shape[1]
    cumulativeEnergyMap = cumulativeEnergyMap.T
    rows, columns = cumulativeEnergyMap.shape
    result = []
    minColumn = 0
    min = cumulativeEnergyMap[rows-1][minColumn]
    for j in range(1, columns):
        if cumulativeEnergyMap[rows-1][j] < min:
            minColumn = j
            min = cumulativeEnergyMap[rows-1][minColumn]
    result.append(minColumn)
    for i in range(rows - 2, -1, -1):
        min = cumulativeEnergyMap[i][minColumn]
        for j in range(minColumn - 1, minColumn + 2):
            if j >= 0 and j < columns:
                if cumulativeEnergyMap[i][j] < min:
                    minColumn = j
                    min = cumulativeEnergyMap[i][minColumn]
        result.append(minColumn)
    return result[::-1]

    ##########################################################################
    # TODO: Find the minimal connected horizontal seam using the input       #
    # cumulative minimum energy map.                                         #
    ##########################################################################

#     return horizontalSeam

def reduce_width(img, energyImage):
    """
    Removes pixels along a seam, reducing the width of the input image by 1 pixel.

    Inputs:
        img: RGB image of shape (H x W x 3) from which a seam is to be removed.
        energyImage: The energy image of the input image.

    Outputs:
        reducedColorImage: The input image whose width has been reduced by 1 pixel
        reducedEnergyImage: The energy image whose width has been reduced by 1 pixel
    """
    rows, columns, channels = img.shape
#     print("energy image size:", energyImage.shape)
    cumulativeEnergyMap = cumulative_minimum_energy_map(energyImage, "VERTICAL")
    verticalSeam = find_optimal_vertical_seam(cumulativeEnergyMap)
    resultimg = np.zeros((rows, columns-1, channels))
    resulteng = np.zeros((rows, columns-1))
    if (len(energyImage.shape) == 3):
        energyImage = rgb2gray(energyImage)
    for i in range(rows):
        column = verticalSeam[i]
        resultimg[i, :column, :] = img[i, :column, ]
        resultimg[i, column:] = img[i, column + 1:]
#         resulteng[i, :column] = energyImage[i, :column]
#         print("shape left", resulteng[i, :column].shape)
#         print("shape right", energyImage[i, :column].shape)
        resulteng[i, :column] = energyImage[i, :column]
        resulteng[i, column:] = energyImage[i, column + 1:]
    return resultimg, resulteng
#     reducedEnergyImageSize = (energyImage.shape[0], energyImage.shape[1] - 1)
#     reducedColorImageSize = (img.shape[0], img.shape[1] - 1, 3)
#     print(reducedEnergyImageSize, reducedColorImageSize)

#     reducedColorImage = np.zeros(reducedColorImageSize)
#     reducedEnergyImage = np.zeros(reducedEnergyImageSize)
#     image = np.copy(img)
#     ##########################################################################
#     # TODO: Compute the cumulative minimum energy map and find the minimal   #
#     # connected vertical seam. Then, remove the pixels along this seam.      #
#     ##########################################################################
#     cumulativeEnergyMap = cumulative_minimum_energy_map(energyImage, "VERTICAL")
#     verticalSeam = find_optimal_vertical_seam(cumulativeEnergyMap)
#     for i in range(image.shape[0]):
#         image.shape[1] = verticalSeam[i]
#         reducedColorImage[i, :image.shape[1],:] = img[i, :image.shape[1],]
#         reducedColorImage[i, image.shape[1]:] = img[i, image.shape[1]+1:]
#         reducedEnergyImage[i, :image.shape[1]] = energyImage[i, :image.shape[1]]
#         reducedEnergyImage[i, image.shape[1]:] = energyImage[i, image.shape[1]+1:]

#     return reducedColorImage, reducedEnergyImage

def reduce_height(img, energyImage):
    """
    Removes pixels along a seam, reducing the height of the input image by 1 pixel.

    Inputs:
        img: RGB image of shape (H x W x 3) from which a seam is to be removed.
        energyImage: The energy image of the input image.

    Outputs:
        reducedColorImage: The input image whose height has been reduced by 1 pixel
        reducedEnergyImage: The energy image whose height has been reduced by 1 pixel
    """

#     reducedEnergyImageSize = tuple((energyImage.shape[0] - 1, energyImage.shape[1]))
#     reducedColorImageSize = tuple((img.shape[0] - 1, img.shape[1], 3))

#     reducedColorImage = np.zeros(reducedColorImageSize)
#     reducedEnergyImage = np.zeros(reducedEnergyImageSize)
#     cumulativeEnergyMap = cumulative_minimum_energy_map(energyImage, "HORIZONTAL")
#     horizontalSeam = find_optimal_horizontal_seam(cumulativeEnergyMap)

#     for i in range(img.shape[1]):
#         temp = list(range(img.shape[0]))
#         temp.remove(horizontalSeam[i])
#         rangeIndex = temp
#         k=0
#         print("dimension of energyImage", reducedEnergyImage.shape)
#         for j in rangeIndex:
#             reducedColorImage[i,k] = img[i,j]
#             reducedEnergyImage[i,k] = img[j]
#             k +=1
#             print(img[j].shape)
#         print("the range is", rangeIndex)
#         print(img[rangeIndex].shape)
#         reducedColorImage[i] = img[rangeIndex]
#         reducedEnergyImage[i]= img[rangeIndex]
    if (len(energyImage.shape) == 3):
        energyImage = rgb2gray(energyImage)
    rows, columns, channels = img.shape
    cumulativeEnergyMap = cumulative_minimum_energy_map(energyImage, "HORIZONTAL")
    horizontalSeam = find_optimal_horizontal_seam(cumulativeEnergyMap)
    resultimg = np.zeros((rows-1, columns, channels))
    resulteng = np.zeros((rows-1, columns))
    for i in range(columns):
        row = horizontalSeam[i]
        resultimg[:row, i, :] = img[:row, i, ]
        resultimg[row:, i] = img[row+1:, i]
        resulteng[:row, i] = energyImage[:row, i]
        resulteng[row:, i] = energyImage[row+1:, i]
    return resultimg, resulteng

    ##########################################################################
    # TODO: Compute the cumulative minimum energy map and find the minimal   #
    # connected horizontal seam. Then, remove the pixels along this seam.    #
    ##########################################################################

#     return reducedColorImage, reducedEnergyImage

def seam_carving_reduce_width(img, reduceBy):
    """
    Reduces the width of the input image by the number pixels passed in reduceBy.

    Inputs:
        img: Input image of shape (H x W X 3)
        reduceBy: Positive non-zero integer indicating the number of pixels the width
        should be reduced by.

    Output:
        reducedColorImage: The result of removing reduceBy number of vertical seams.
    """

    reducedColorImage = img[:, reduceBy//2:-reduceBy//2, :]  #crops the image

    ##########################################################################
    # TODO: For the Prague image, write a few lines of code to call the      #
    # we have written to find and remove 100 vertical seams                  #
    ##########################################################################
    im = np.copy(reducedColorImage).astype(np.uint8)
    if (len(im.shape)!=3):
        im = np.stack((O,im, im), axis=2)
#         im = rgb2gray(im)
    for i in range(reduceBy):
        im, energy_im = reduce_width(im, energy_image(im.astype(np.uint8)))
    im /= 255
    return im
#     R = np.stack((O,dim, dim), axis=2)
#     return reducedColorImage

def seam_carving_reduce_height(img, reduceBy):
    """
    Reduces the height of the input image by the number pixels passed in reduceBy.

    Inputs:
        img: Input image of shape (H x W X 3)
        reduceBy: Positive non-zero integer indicating the number of pixels the
        height should be reduced by.

    Output:
        reducedColorImage: The result of removing reduceBy number of horizontal
        seams.
    """

    reducedColorImage = img[reduceBy//2:-reduceBy//2, :, :]  #crops the image

    ##########################################################################
    # TODO: For the Prague image, write a few lines of code to call the      #
    # we have written to find and remove 100 horizontal seams.               #
    ##########################################################################
    im = np.copy(reducedColorImage).astype(np.uint8)
    if (len(im.shape)!=3):
        im = np.stack((O,im, im), axis=2)
    for i in range(reduceBy):
        im, energy_im = reduce_height(im, energy_image(im.astype(np.uint8)))
    im /= 255
    return im